{
  parserClass="se.clau.intellijlux.parser.LuxParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lux"
  psiImplClassSuffix="Impl"
  psiPackage="se.clau.intellijlux.psi"
  psiImplPackage="se.clau.intellijlux.impl"

  elementTypeHolderClass="se.clau.intellijlux.psi.LuxTypes"
  elementTypeClass="se.clau.intellijlux.psi.LuxElementType"
  tokenTypeClass="se.clau.intellijlux.psi.LuxTokenType"
  tokens=[
    T_BANG = "!"
    T_TILDE = "~"
    T_TRIPLE_QUESTION = "???"
    T_DOUBLE_QUESTION = "??"
    T_QUESTION_PLUS = "?+"
    T_QUESTION = "?"l
    T_MINUS = "-"
    T_PLUS = "+"
    T_AT = "@"
    T_SQR_OPEN = "["
    T_SQR_CLOSE = "]"
  ]
}

luxFile ::= item *

private item ::= (
    COMMENT | CRLF
    | meta_doc | K_END_DOC
    | meta_shell | meta_newshell
    | meta_timeout | meta_sleep
    | meta_config | meta_local | meta_global | meta_my
    | K_CLEANUP | meta_include
    | meta_macro | K_END_MACRO | meta_invoke
    | meta_loop | K_END_LOOP
    | meta_progress
    | send | send_ln | expect_verbatim | expect_template | expect_regex
    | flush | expect_maybe_regex | set_failure | set_success | set_loop_break
    )

//metaDocBegin ::= '[doc]'
//metaDocEnd ::= '[enddoc]'
meta_doc ::= K_DOC_ONLY | (K_DOC meta_contents)
flush ::= K_FLUSH

meta_shell ::= K_SHELL_ONLY | (K_SHELL T_IDENT meta_contents)
meta_newshell ::= K_NEWSHELL_ONLY | (K_NEWSHELL meta_contents)
meta_timeout ::= K_TIMEOUT_ONLY | (K_TIMEOUT inner_number)
meta_sleep ::= K_SLEEP inner_number
meta_include ::= K_INCLUDE meta_contents
meta_macro ::= (K_MACRO T_IDENT) meta_contents
meta_invoke ::= (K_INVOKE T_IDENT) meta_contents
meta_loop ::= (K_LOOP T_IDENT) meta_contents
meta_progress ::= K_PROGRESS meta_contents

private inner inner_number ::= T_NUMBER T_SQR_CLOSE CRLF
private inner meta_contents ::= ( meta_element * ) END_META
private meta_element ::= TEXT | paste

meta_config ::= K_CONFIG inner_x_equals_y
meta_local ::= K_LOCAL inner_x_equals_y
meta_global ::= K_GLOBAL inner_x_equals_y
meta_my ::= K_MY inner_x_equals_y

private inner inner_x_equals_y ::= T_IDENT T_EQUALS meta_contents

send ::= (K_SEND inner_line) | (K_ML_SEND inner_multiline)
send_ln ::= (K_SEND_LN inner_line) | (K_ML_SEND_LN inner_multiline)
expect_verbatim ::= (K_EXP_VERBATIM inner_line) | (K_ML_EXP_VERBATIM inner_multiline)
expect_template ::= (K_EXP_TEMPLATE inner_line) | (K_ML_EXP_TEMPLATE inner_multiline)
expect_regex ::= (K_EXP_REGEX inner_line) | (K_ML_EXP_REGEX inner_multiline)
expect_maybe_regex ::= (K_EXP_MAYBE_REGEX inner_line) | (K_ML_EXP_MAYBE_REGEX inner_multiline)
set_failure ::= K_SET_FAILURE_ONLY | (K_SET_FAILURE inner_line) | (K_ML_SET_FAILURE inner_multiline)
set_success ::= K_SET_SUCCESS_ONLY | (K_SET_SUCCESS inner_line) | (K_ML_SET_SUCCESS inner_multiline)
set_loop_break ::= K_SET_LOOP_BREAK_ONLY | (K_SET_LOOP_BREAK inner_line) | (K_ML_SET_LOOP_BREAK inner_multiline)

private inner inner_line ::= line_contents * CRLF
// LINE_CONTINUATION in line_contents for when it is broken with \\
private line_contents ::= TEXT | paste | LINE_CONTINUATION

private inner inner_multiline ::= multiline_contents * END_MULTILINE
private multiline_contents ::= TEXT | paste | CRLF

// A pasted value $name ${name} or $123
private paste ::= T_DOLLAR | T_PASTE_VARIABLE | T_PASTE_CAPTURE

//setFailure0 ::= '-' CRLF
//setFailure ::= '-' regex CRLF
//setSuccess0 ::= '+' CRLF
//setSuccess ::= '+' regex CRLF
//setBreak0 ::= '@' CRLF
//setBreak ::= '@' regex CRLF
